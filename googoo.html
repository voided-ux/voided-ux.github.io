<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB Model Viewer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Inter', sans-serif;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #ui-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .select-button {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            background-color: #4a5568;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .select-button:hover {
            background-color: #2d3748;
        }

        #message {
            font-size: 14px;
            color: #a0aec0;
            text-align: center;
            white-space: nowrap;
        }

        #controls-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            color: white;
            pointer-events: none;
            z-index: 200;
        }

        #lock-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 25px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            color: white;
            font-size: 18px;
            pointer-events: none;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
</head>
<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <p class="loading-text">Loading Model...</p>
    </div>
    <div id="ui-container">
        <button id="file-select-button" class="select-button">Select GLB File</button>
        <input type="file" id="file-input" accept=".glb" style="display: none;">
        <p id="message">No model loaded. Please select a .glb file.</p>
    </div>
    <div id="controls-info">
        <p>Controls:</p>
        <p><b>W/A/S/D</b>: Move</p>
        <p><b>Space</b>: Jump</p>
        <p>Click and hold for mouse look</p>
    </div>
    <div id="lock-message">Click to activate controls</div>

    <script>
        window.onload = function() {
            // --- Scene Setup ---
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x282c34);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Player and camera objects
            const yawObject = new THREE.Object3D(); // Horizontal rotation
            const pitchObject = new THREE.Object3D(); // Vertical rotation
            yawObject.add(pitchObject);
            pitchObject.add(camera);
            scene.add(yawObject);
            camera.position.set(0, 1.6, 0); // Position the camera at head height

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // --- Physics World Setup ---
            const world = new CANNON.World();
            world.gravity.set(0, -15, 0); // Increased gravity for more realistic feel
            const fixedTimeStep = 1 / 60;
            const maxSubSteps = 10;
            // Player hitbox is now more human-like, making movement feel more responsive and less "floaty."
            const playerBody = new CANNON.Body({ mass: 1, shape: new CANNON.Cylinder(0.25, 0.25, 1.5, 16), position: new CANNON.Vec3(0, 20, 0), angularFactor: new CANNON.Vec3(0, 1, 0) });
            
            const playerMaterial = new CANNON.Material('playerMaterial');
            const groundMaterial = new CANNON.Material('groundMaterial');
            const playerGroundContactMaterial = new CANNON.ContactMaterial(groundMaterial, playerMaterial, {
                friction: 0.0,
                restitution: 0.0
            });
            world.addContactMaterial(playerGroundContactMaterial);
            playerBody.material = playerMaterial;
            
            let isGrounded = false;
            // Check for ground collision to enable jumping
            playerBody.addEventListener('collide', (e) => {
                const contact = e.contact;
                if(contact.bi.id === playerBody.id) {
                    contact.ni.negate(contact.ni);
                }
                if (contact.ni.y > 0.5) { // Check if the collision normal is pointing upwards
                    isGrounded = true;
                }
            });

            world.addBody(playerBody);

            // --- GLB Loader and DRACOLoader ---
            const loader = new THREE.GLTFLoader();
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            loader.setDRACOLoader(dracoLoader);

            // --- UI Elements and Logic ---
            const fileInput = document.getElementById('file-input');
            const fileSelectButton = document.getElementById('file-select-button');
            const messageElement = document.getElementById('message');
            const loadingOverlay = document.getElementById('loading-overlay');
            const lockMessage = document.getElementById('lock-message');

            fileSelectButton.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) {
                    messageElement.innerText = 'No file selected.';
                    return;
                }

                messageElement.innerText = 'Loading...';
                loadingOverlay.style.display = 'flex';
                loadingOverlay.style.opacity = '1';

                const reader = new FileReader();
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;
                    // Clear previous content
                    scene.children.forEach(child => {
                        if (child.isObject3D && child.name.includes('GLTF_Model')) {
                            scene.remove(child);
                        }
                    });
                    // Remove old physics bodies
                    while(world.bodies.length > 1) { // Keep the player body
                        world.removeBody(world.bodies[1]);
                    }

                    loader.parse(arrayBuffer, '', (gltf) => {
                        gltf.scene.name = 'GLTF_Model';
                        scene.add(gltf.scene);

                        // Create a separate Trimesh for each collider mesh
                        gltf.scene.traverse((child) => {
                            if (child.isMesh && (child.name.toLowerCase().includes('collider') || child.name.toLowerCase().includes('ground') || child.name.toLowerCase().includes('road'))) {
                                const geometry = child.geometry;
                                const positionAttribute = geometry.attributes.position;
                                
                                // Get vertices and apply mesh transformations
                                const vertices = [];
                                const positionArray = positionAttribute.array;
                                const tempVec = new THREE.Vector3();
                                for (let i = 0; i < positionArray.length; i += 3) {
                                    tempVec.set(positionArray[i], positionArray[i+1], positionArray[i+2]);
                                    child.localToWorld(tempVec);
                                    vertices.push(tempVec.x, tempVec.y, tempVec.z);
                                }
                                
                                // Get indices
                                const indices = geometry.index ? Array.from(geometry.index.array) : Array.from({ length: positionArray.length / 3 }, (_, i) => i);

                                // Create a single Trimesh for the mesh
                                if (vertices.length > 0) {
                                    const groundShape = new CANNON.Trimesh(vertices, indices);
                                    const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
                                    groundBody.addShape(groundShape);
                                    world.addBody(groundBody);
                                }
                            }
                        });

                        console.log('Model loaded successfully');
                        messageElement.innerText = `Model "${file.name}" loaded.`;
                        loadingOverlay.style.opacity = '0';
                        setTimeout(() => loadingOverlay.style.display = 'none', 500);
                        lockMessage.style.opacity = '1';

                    },
                    (error) => {
                        console.error('An error happened while loading the model:', error);
                        messageElement.innerText = 'Error loading model! It might be a Draco compression issue.';
                        loadingOverlay.style.opacity = '0';
                        setTimeout(() => loadingOverlay.style.display = 'none', 500);
                    });
                };
                reader.onerror = (e) => {
                    console.error('FileReader error:', e);
                    messageElement.innerText = 'Error reading file!';
                    loadingOverlay.style.opacity = '0';
                    setTimeout(() => loadingOverlay.style.display = 'none', 500);
                };
                reader.readAsArrayBuffer(file);
            });

            // --- Player Controls and Pointer Lock ---
            const keys = {};
            document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

            let mouseX = 0, mouseY = 0;
            const mouseSensitivity = 0.002;
            let isLocked = false;
            
            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === document.body;
                if (isLocked) {
                    lockMessage.style.opacity = '0';
                } else {
                    lockMessage.style.opacity = '1';
                }
            });

            document.addEventListener('mousedown', () => {
                document.body.requestPointerLock();
            });

            document.addEventListener('mousemove', (event) => {
                if (isLocked) {
                    yawObject.rotation.y -= event.movementX * mouseSensitivity;
                    pitchObject.rotation.x -= event.movementY * mouseSensitivity;
                    pitchObject.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchObject.rotation.x));
                }
            });
            
            // --- Animation Loop ---
            let lastTime = 0;
            const animate = (time) => {
                requestAnimationFrame(animate);
                const dt = time !== undefined ? (time - lastTime) / 1000 : fixedTimeStep;
                lastTime = time;

                // Check for fall and teleport if needed
                if (playerBody.position.y < -20) {
                    playerBody.position.set(0, 50, 0); // Teleport to a high starting point
                    playerBody.velocity.set(0, 0, 0); // Reset velocity
                }

                // Update physics world with a fixed time step to prevent clipping
                world.step(fixedTimeStep, dt, maxSubSteps);

                // Movement
                const speed = 5;
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(yawObject.quaternion);
                forward.normalize();

                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(yawObject.quaternion);
                right.normalize();

                const velocity = new CANNON.Vec3(0, playerBody.velocity.y, 0);
                
                if (keys['w']) velocity.vadd(new CANNON.Vec3(forward.x, 0, forward.z).scale(speed), velocity);
                if (keys['s']) velocity.vadd(new CANNON.Vec3(-forward.x, 0, -forward.z).scale(speed), velocity);
                if (keys['a']) velocity.vadd(new CANNON.Vec3(-right.x, 0, -right.z).scale(speed), velocity);
                if (keys['d']) velocity.vadd(new CANNON.Vec3(right.x, 0, right.z).scale(speed), velocity);

                // Jumping
                if (isGrounded && keys[' ']) {
                    velocity.y = 7;
                    isGrounded = false; // Prevent repeated jumping
                }

                playerBody.velocity.set(velocity.x, velocity.y, velocity.z);
                
                // Copy physics body position to the camera holder, adding an offset to align with the hitbox center
                yawObject.position.copy(playerBody.position).add(new THREE.Vector3(0, 0.75, 0));

                renderer.render(scene, camera);
            };
            animate();

            // --- Handle Window Resizing ---
            window.addEventListener('resize', () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
        };
    </script>
</body>
</html>
